# DocDB v0.3 Low-Contention Configuration: 6 Databases × 1 Worker

**Test Date**: January 29, 2026  
**Version**: v0.3  
**Duration**: 300 seconds (5 minutes)

## Executive Summary

**Key Finding**: Using **1 worker per database** (6 DBs × 1 worker = 6 total workers) achieved the **best throughput and lowest latency** of all tested configurations:

- **Throughput**: **742.8 ops/sec** (vs 672.3 with 3×10) = **+10.5% increase** ✅
- **P95 Latency**: **~28ms average** (vs ~110ms with 3×10) = **-74.5% reduction** ✅
- **Read P95**: **6.6ms** (vs 103.6ms) = **-93.6% reduction** ✅
- **Total Operations**: **222,929** in 5 minutes (highest of all tests)

**Conclusion**: **Eliminating intra-database lock contention** (1 worker per DB) yields both higher throughput and dramatically lower latency. This configuration is **optimal for latency-sensitive workloads**.

---

## Test Configuration

- **Databases**: 6 (db1, db2, db3, d5, d6, d7)
- **Workers per Database**: 1
- **Total Workers**: 6
- **CRUD Mix**: 40% Read, 30% Create, 20% Update, 10% Delete
- **Document Size**: 1024 bytes
- **Document Count**: 10,000 per database

---

## Performance: 6 DBs × 1 Worker

### Global Latency (Percentiles)

| Operation  | P50 (ms) | P95 (ms) | P99 (ms) | P999 (ms) | Mean (ms) | Min (ms) | Max (ms) |
| ---------- | -------- | -------- | -------- | --------- | --------- | -------- | -------- |
| **Create** | 0.75     | 35.3     | 50.4     | 77.3      | 9.2       | 0.023    | 111.9    |
| **Read**   | 0.28     | **6.6**  | 13.5     | 25.8      | 1.4       | 0.013    | 89.5     |
| **Update** | 22.2     | 43.7     | 62.6     | 93.1      | 20.3      | 0.025    | 180.7    |
| **Delete** | 0.40     | 26.8     | 41.4     | 64.7      | 6.7       | 0.013    | 98.0     |

**Highlights**:

- **Read P95: 6.6ms** – Sub-10ms read latency
- **Read P50: 0.28ms** – Median read under 1ms
- **Create P95: 35.3ms** – Writes well under 50ms
- **Update P95: 43.7ms** – Heaviest op still under 50ms

### Per-Database Operations

| Database  | Total Ops   | Ops/sec   | Create     | Read       | Update     | Delete     |
| --------- | ----------- | --------- | ---------- | ---------- | ---------- | ---------- |
| **db1**   | 37,049      | 123.5     | 11,212     | 14,763     | 7,398      | 3,676      |
| **db2**   | 37,154      | 123.8     | 11,134     | 14,876     | 7,403      | 3,741      |
| **db3**   | 37,082      | 123.6     | 11,089     | 14,821     | 7,404      | 3,708      |
| **d5**    | 36,504      | 121.7     | 11,021     | 14,422     | 7,417      | 3,644      |
| **d6**    | 36,650      | 122.2     | 10,972     | 14,654     | 7,331      | 3,693      |
| **d7**    | 36,607      | 122.0     | 10,965     | 14,508     | 7,419      | 3,715      |
| **Total** | **222,929** | **742.8** | **66,753** | **88,776** | **44,863** | **22,537** |

**Analysis**: Excellent balance – per-DB ops within 2% variance.

### WAL Growth

- **Total WAL Growth**: ~59.5 MB over 300s (~198 KB/s)
- **Per-DB**: ~33 KB/s each (consistent across databases)

---

## Comparison: All Tested Configurations

| Configuration   | Total Workers | Ops/sec   | P95 Avg (ms) | Read P95 (ms) | Per-Worker Ops/sec |
| --------------- | ------------- | --------- | ------------ | ------------- | ------------------ |
| **6 DBs × 1W**  | 6             | **742.8** | **~28**      | **6.6**       | **123.8** ✅       |
| **3 DBs × 10W** | 30            | 672.3     | 110.2        | 103.6         | 22.4               |
| **7 DBs × 10W** | 70            | 627.8     | 222.8        | 206.8         | 9.0                |
| **3 DBs × 20W** | 60            | 619.7     | 182.0        | 174.4         | 10.3               |

**Insights**:

1. **6×1 has highest throughput** despite fewest workers (6).
2. **6×1 has lowest latency** by a large margin (P95 ~28ms vs 110–223ms).
3. **Per-worker efficiency**: 123.8 ops/sec per worker (6×1) vs 22.4 (3×10) – **5.5× more efficient** with 1 worker/DB.

---

## Why 1 Worker per Database Wins

### Lock Contention Within a Database

- **Multiple workers per DB**: They contend for `LogicalDB` write lock and index shards. Only one writer per DB at a time; others block → queueing and high latency.
- **One worker per DB**: No concurrent writers per DB → **no intra-DB lock contention**. Each worker owns its DB’s write path.

### Effect on Metrics

- **Throughput**: Less time spent waiting on locks → more useful work → **higher ops/sec**.
- **Latency**: No lock wait in the critical path → **P50/P95/P99 drop sharply**, especially for reads (no write lock, but shared structures still benefit from less write contention).
- **Reads**: With no competing writers on the same DB, read path is fast → **Read P95 6.6ms**.

### Scheduler and Horizontal Scaling

- With 1 worker per DB, the scheduler’s job is to choose **which DB’s single worker** runs next. Fewer workers, less queue depth per DB, and no lock contention inside each DB.
- With 6 DBs, total concurrency (6) is low, so scheduler and pool overhead stay small while still utilizing multiple DBs.

---

## Latency Comparison (P95)

| Operation   | 6×1 (ms) | 3×10 (ms) | 7×10 (ms) | Best       |
| ----------- | -------- | --------- | --------- | ---------- |
| **Create**  | 35.3     | 110.8     | 234.0     | **6×1** ✅ |
| **Read**    | **6.6**  | 103.6     | 206.8     | **6×1** ✅ |
| **Update**  | 43.7     | 119.6     | 236.2     | **6×1** ✅ |
| **Delete**  | 26.8     | 106.8     | 214.0     | **6×1** ✅ |
| **Average** | **28.1** | 110.2     | 222.8     | **6×1** ✅ |

---

## Recommendations

### 1. Latency-Sensitive Workloads

- **Prefer 1 worker per database**.
- Scale out by adding databases (e.g. 6–10 DBs × 1 worker) and re-test to find where scheduler or I/O becomes the limit.

### 2. Throughput vs Latency

- **Best measured throughput and latency**: 6 DBs × 1 worker (742 ops/sec, P95 ~28ms).
- **3 DBs × 10 workers**: Good balance (672 ops/sec, P95 ~110ms) if you want fewer DBs and more workers per DB, accepting higher latency.

### 3. When to Use Multiple Workers per DB

- Only if a single worker cannot saturate one DB (e.g. very large payloads or heavy per-op work). Current results show that **adding workers per DB increases contention and hurts both throughput and latency**.

### 4. Horizontal Scaling with 1 Worker/DB

- Next step: test 4, 5, 7, 8 DBs with 1 worker each to see where throughput peaks and scheduler overhead starts to dominate.

---

## Conclusion

**1 worker per database is the best-tested configuration for v0.3** on this workload:

- **Highest throughput**: 742.8 ops/sec (6 DBs × 1 worker).
- **Lowest latency**: P95 ~28ms overall, Read P95 6.6ms.
- **Root cause**: No lock contention within each LogicalDB when only one worker writes per DB.

For **low-latency and high throughput**, use **1 worker per database** and scale by adding databases; avoid increasing workers per database without evidence that a single worker is the bottleneck.

---

## Test Artifacts

- **Results JSON**: `multidb_results-3.json`
- **Test Command**:
  ```bash
  go run docdb/tests/load/cmd/multidb_loadtest/main.go \
    -databases db1,db2,db3,d5,d6,d7 \
    -workers-per-db 1 \
    -duration 5m \
    -socket /tmp/docdb.sock \
    -wal-dir ./docdb/data/wal \
    -output multidb_results-3.json \
    -csv
  ```
