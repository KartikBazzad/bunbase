// Package transaction manages the lifecycle of database transactions.
//
// It ensures ACID properties:
// - **Atomicity**: Transactions are either fully committed or fully rolled back.
// - **Consistency**: Maintained via application logic and integrity constraints.
// - **Isolation**: Managed via MVCC and Snapshots.
// - **Durability**: Guaranteed via Write-Ahead Logging (WAL).
package transaction

import (
	"fmt"
	"sync"
	"sync/atomic"

	"github.com/kartikbazzad/bunbase/bundoc/internal/wal"
	"github.com/kartikbazzad/bunbase/bundoc/mvcc"
)

// Status represents the lifecycle state of a transaction.
type Status int

const (
	StatusActive    Status = iota // Transaction is running
	StatusCommitted               // Transaction successfully completed
	StatusAborted                 // Transaction failed or was rolled back
)

// Transaction represents a unit of work.
// It buffers all writes in a `WriteSet` until Commit time, ensuring Atomic updates.
type Transaction struct {
	ID             uint64
	Snapshot       *mvcc.Snapshot
	Status         Status
	WriteSet       map[string][]byte // Writes buffered in memory before commit
	ReadSet        map[string]bool   // Tracked for conflict detection (optimistic concurrency)
	WALRecords     []*wal.Record     // Log records generated by this txn
	IsolationLevel mvcc.IsolationLevel
	isReadOnly     bool // Optimization flag: Read-only txns skip WAL sync
	mu             sync.RWMutex
}

// TransactionManager manages database transactions
type TransactionManager struct {
	nextTxnID      atomic.Uint64
	activeTxns     map[uint64]*Transaction
	snapshotMgr    *mvcc.SnapshotManager
	walWriter      *wal.WAL
	groupCommitter *wal.GroupCommitter
	mu             sync.RWMutex
}

// NewTransactionManager creates a new transaction manager
func NewTransactionManager(sm *mvcc.SnapshotManager, walWriter *wal.WAL) *TransactionManager {
	tm := &TransactionManager{
		activeTxns:  make(map[uint64]*Transaction),
		snapshotMgr: sm,
		walWriter:   walWriter,
	}
	tm.nextTxnID.Store(1)

	// Create group committer
	tm.groupCommitter = wal.NewGroupCommitter(walWriter)

	return tm
}

// Begin starts a new transaction with the specified isolation level
func (tm *TransactionManager) Begin(level mvcc.IsolationLevel) (*Transaction, error) {
	// Generate transaction ID
	txnID := tm.nextTxnID.Add(1)

	// Create snapshot for this transaction
	snapshot := tm.snapshotMgr.BeginSnapshot(txnID, level)

	// Create transaction (assume read-only until first write)
	txn := &Transaction{
		ID:             txnID,
		Snapshot:       snapshot,
		Status:         StatusActive,
		WriteSet:       make(map[string][]byte),
		ReadSet:        make(map[string]bool),
		WALRecords:     make([]*wal.Record, 0),
		IsolationLevel: level,
		isReadOnly:     true, // Assume read-only until proven otherwise
	}

	// Register transaction
	tm.mu.Lock()
	tm.activeTxns[txnID] = txn
	tm.mu.Unlock()

	return txn, nil
}

// Commit finalizes the transaction.
//
// Steps:
// 1. **Read-Only Optimization**: If no writes occurred, simply release the snapshot and return.
// 2. **WAL Preparation**: Convert all buffered writes into WAL records.
// 3. **Batch Append**: Write all records + Commit Marker to the WAL in one batch.
// 4. **Sync**: Use GroupCommitter to durable flush to disk (fsync).
// 5. **Visibility**: Mark transaction as committed in SnapshotManager (making writes visible).
// 6. **Cleanup**: Release resources.
func (tm *TransactionManager) Commit(txn *Transaction) error {
	txn.mu.Lock()
	if txn.Status != StatusActive {
		txn.mu.Unlock()
		return fmt.Errorf("transaction %d is not active", txn.ID)
	}

	// Fast path for read-only transactions (skip WAL entirely!)
	if txn.isReadOnly {
		txn.Status = StatusCommitted
		txn.mu.Unlock()

		// Release snapshot
		tm.snapshotMgr.ReleaseSnapshot(txn.Snapshot)

		// Unregister transaction
		tm.mu.Lock()
		delete(tm.activeTxns, txn.ID)
		tm.mu.Unlock()

		return nil
	}

	// Prepare all records
	var records []*wal.Record
	var lastLSN wal.LSN

	// Add insert/update/delete records
	for key, value := range txn.WriteSet {
		record := &wal.Record{
			TxnID:     txn.ID,
			Type:      wal.RecordTypeInsert,
			Key:       []byte(key),
			Value:     value,
			PrevLSN:   lastLSN, // Note: PrevLSN calculation might need refinement for batch, typically strictly sequential per txn isn't needed for correctness if whole txn commits
			Timestamp: int64(txn.Snapshot.Timestamp),
		}
		records = append(records, record)
	}

	// Add commit record
	commitRecord := &wal.Record{
		TxnID:     txn.ID,
		Type:      wal.RecordTypeCommit,
		PrevLSN:   lastLSN, // Will be updated by AppendBatch logic if we tracked it, but simple append works
		Timestamp: int64(txn.Snapshot.Timestamp),
	}
	records = append(records, commitRecord)

	// Write all records in one batch
	commitLSN, err := tm.walWriter.AppendBatch(records)
	if err != nil {
		txn.mu.Unlock()
		return fmt.Errorf("failed to write WAL records: %w", err)
	}

	txn.Status = StatusCommitted
	txn.mu.Unlock()

	// Use group committer to fsync
	if err := tm.groupCommitter.Commit(commitLSN); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Mark transaction as committed in snapshot manager
	tm.snapshotMgr.CommitTransaction(txn.ID)

	// Release snapshot
	tm.snapshotMgr.ReleaseSnapshot(txn.Snapshot)

	// Unregister transaction
	tm.mu.Lock()
	delete(tm.activeTxns, txn.ID)
	tm.mu.Unlock()

	return nil
}

// Rollback rolls back a transaction
func (tm *TransactionManager) Rollback(txn *Transaction) error {
	txn.mu.Lock()
	if txn.Status != StatusActive {
		txn.mu.Unlock()
		return fmt.Errorf("transaction %d is not active", txn.ID)
	}

	// Write abort record to WAL
	abortRecord := &wal.Record{
		TxnID:     txn.ID,
		Type:      wal.RecordTypeAbort,
		Timestamp: int64(txn.Snapshot.Timestamp),
	}

	if _, err := tm.walWriter.Append(abortRecord); err != nil {
		txn.mu.Unlock()
		return fmt.Errorf("failed to write abort record: %w", err)
	}

	txn.Status = StatusAborted
	txn.mu.Unlock()

	// Mark transaction as aborted in snapshot manager
	tm.snapshotMgr.AbortTransaction(txn.ID)

	// Release snapshot
	tm.snapshotMgr.ReleaseSnapshot(txn.Snapshot)

	// Unregister transaction
	tm.mu.Lock()
	delete(tm.activeTxns, txn.ID)
	tm.mu.Unlock()

	return nil
}

// Read reads a value for a transaction
func (tm *TransactionManager) Read(txn *Transaction, key string) ([]byte, error) {
	txn.mu.Lock()
	defer txn.mu.Unlock()

	if txn.Status != StatusActive {
		return nil, fmt.Errorf("transaction %d is not active", txn.ID)
	}

	// Track read for conflict detection
	txn.ReadSet[key] = true

	// Check if we've written this key in this transaction
	if value, exists := txn.WriteSet[key]; exists {
		return value, nil
	}

	// In a full implementation, would read from storage and check visibility
	// For now, return placeholder
	return nil, fmt.Errorf("key not found: %s", key)
}

// Write writes a value in a transaction
func (tm *TransactionManager) Write(txn *Transaction, key string, value []byte) error {
	txn.mu.Lock()
	defer txn.mu.Unlock()

	if txn.Status != StatusActive {
		return fmt.Errorf("transaction %d is not active", txn.ID)
	}

	// Mark as NOT read-only (first write)
	if txn.isReadOnly {
		txn.isReadOnly = false
	}

	// Store in write set (will be flushed on commit)
	txn.WriteSet[key] = value

	return nil
}

// GetActiveTransactionCount returns the number of active transactions
func (tm *TransactionManager) GetActiveTransactionCount() int {
	tm.mu.RLock()
	defer tm.mu.RUnlock()
	return len(tm.activeTxns)
}

// Close closes the transaction manager
func (tm *TransactionManager) Close() error {
	// Stop group committer
	tm.groupCommitter.Stop()
	return nil
}
